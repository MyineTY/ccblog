(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{327:function(v,_,l){"use strict";l.r(_);var i=l(4),a=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"八股要点-并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#八股要点-并发"}},[v._v("#")]),v._v(" 八股要点 # 并发")]),v._v(" "),_("h2",{attrs:{id:"基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[v._v("#")]),v._v(" 基础")]),v._v(" "),_("ul",[_("li",[v._v("[ ] 什么是线程和进程?\n进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位")]),v._v(" "),_("li",[v._v("[ ] Java 线程和操作系统的线程有啥区别？")]),v._v(" "),_("li",[v._v("[ ] 请简要描述线程与进程的关系,区别及优缺点？")]),v._v(" "),_("li",[v._v("[ ] 程序计数器为什么是私有的?")]),v._v(" "),_("li",[v._v("[ ] 虚拟机栈和本地方法栈为什么是私有的?")]),v._v(" "),_("li",[v._v("[ ] 并发与并行的区别")]),v._v(" "),_("li",[v._v("[ ] 同步和异步的区别")]),v._v(" "),_("li",[v._v("[ ] 为什么要使用多线程?")]),v._v(" "),_("li",[v._v("[ ] 使用多线程可能带来什么问题?")]),v._v(" "),_("li",[v._v("[ ] 如何理解线程安全和不安全？")]),v._v(" "),_("li",[v._v("[ ] 单核 CPU 上运行多个线程效率一定会高吗？")]),v._v(" "),_("li",[v._v("[ ] 如何创建线程？")]),v._v(" "),_("li",[v._v("[ ] 说说线程的生命周期和状态?")]),v._v(" "),_("li",[v._v("[ ] 什么是线程上下文切换?")]),v._v(" "),_("li",[v._v("[ ] 什么是线程死锁?如何避免死锁?")]),v._v(" "),_("li",[v._v("[ ] 如何预防和避免线程死锁?")]),v._v(" "),_("li",[v._v("[ ]  sleep() 方法和 wait() 方法对比")]),v._v(" "),_("li",[v._v("[ ] 为什么 wait() 方法不定义在 Thread 中？")]),v._v(" "),_("li",[v._v("[ ] 可以直接调用 Thread 类的 run 方法吗？")])]),v._v(" "),_("h2",{attrs:{id:"jmm-java-内存模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jmm-java-内存模型"}},[v._v("#")]),v._v(" JMM(Java 内存模型)")]),v._v(" "),_("ul",[_("li",[v._v("[ ] 什么是 JMM？为什么需要 JMM？")]),v._v(" "),_("li",[v._v("[ ] JMM 是如何抽象线程和主内存之间的关系？")]),v._v(" "),_("li",[v._v("[ ] Java 内存区域和 JMM 有何区别？")]),v._v(" "),_("li",[v._v("[ ] happens-before 原则是什么？")]),v._v(" "),_("li",[v._v("[ ] happens-before 和 JMM 什么关系？")])]),v._v(" "),_("h2",{attrs:{id:"并发编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发编程"}},[v._v("#")]),v._v(" 并发编程")]),v._v(" "),_("ul",[_("li",[v._v("[ ] 并发编程三个重要特性")]),v._v(" "),_("li",[v._v("[ ] volatile 关键字")]),v._v(" "),_("li",[v._v("[ ] 如何保证变量的可见性？")]),v._v(" "),_("li",[v._v("[ ] 如何禁止指令重排序？")]),v._v(" "),_("li",[v._v("[ ] volatile 可以保证原子性么？")]),v._v(" "),_("li",[v._v("[ ] 乐观锁和悲观锁")]),v._v(" "),_("li",[v._v("[ ] 什么是悲观锁？")]),v._v(" "),_("li",[v._v("[ ] 什么是乐观锁？")]),v._v(" "),_("li",[v._v("[ ] 如何实现乐观锁？")]),v._v(" "),_("li",[v._v("[ ] 乐观锁存在哪些问题？")]),v._v(" "),_("li",[v._v("[ ] synchronized 关键字")]),v._v(" "),_("li",[v._v("[ ] synchronized 是什么？有什么用？")]),v._v(" "),_("li",[v._v("[ ] 如何使用 synchronized？")]),v._v(" "),_("li",[v._v("[ ] 构造方法可以用 synchronized 修饰么？")]),v._v(" "),_("li",[v._v("[ ] JDK1.6 之后的 synchronized 底层做了哪些优化？锁升级原理了解吗？")]),v._v(" "),_("li",[v._v("[ ] synchronized 和 volatile 有什么区别？")])]),v._v(" "),_("h2",{attrs:{id:"并发锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发锁"}},[v._v("#")]),v._v(" 并发锁")]),v._v(" "),_("ul",[_("li",[v._v("[ ] ReentrantLock")]),v._v(" "),_("li",[v._v("[ ] ReentrantLock 是什么？")]),v._v(" "),_("li",[v._v("[ ] 公平锁和非公平锁有什么区别？")]),v._v(" "),_("li",[v._v("[ ] synchronized 和 ReentrantLock 有什么区别？")]),v._v(" "),_("li",[v._v("[ ] 可中断锁和不可中断锁有什么区别？")]),v._v(" "),_("li",[v._v("[ ] ReentrantReadWriteLock")]),v._v(" "),_("li",[v._v("[ ] ReentrantReadWriteLock 是什么？")]),v._v(" "),_("li",[v._v("[ ] ReentrantReadWriteLock 适合什么场景？")]),v._v(" "),_("li",[v._v("[ ] 共享锁和独占锁有什么区别？")]),v._v(" "),_("li",[v._v("[ ] 线程持有读锁还能获取写锁吗？")]),v._v(" "),_("li",[v._v("[ ] 读锁为什么不能升级为写锁？")])]),v._v(" "),_("h2",{attrs:{id:"threadlocal"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal"}},[v._v("#")]),v._v(" ThreadLocal")]),v._v(" "),_("ul",[_("li",[v._v("[ ] ThreadLocal 有什么用？")]),v._v(" "),_("li",[v._v("[ ] 如何使用 ThreadLocal？")]),v._v(" "),_("li",[v._v("[ ] ThreadLocal 原理了解吗？")]),v._v(" "),_("li",[v._v("[ ] ThreadLocal 内存泄露问题是怎么导致的？")])]),v._v(" "),_("h2",{attrs:{id:"线程池-线性池"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程池-线性池"}},[v._v("#")]),v._v(" 线程池 [[线性池]]")]),v._v(" "),_("ul",[_("li",[v._v("[ ] 什么是线程池?")]),v._v(" "),_("li",[v._v("[ ] 为什么要用线程池？")]),v._v(" "),_("li",[v._v("[ ] 如何创建线程池？")]),v._v(" "),_("li",[v._v("[ ] 为什么不推荐使用内置线程池？")]),v._v(" "),_("li",[v._v("[ ] 线程池常见参数有哪些？如何解释？")]),v._v(" "),_("li",[v._v("[ ] 线程池的饱和策略有哪些？")]),v._v(" "),_("li",[v._v("[ ] 线程池常用的阻塞队列有哪些？")]),v._v(" "),_("li",[v._v("[ ] 线程池处理任务的流程了解吗？")]),v._v(" "),_("li",[v._v("[ ] 如何给线程池命名？")]),v._v(" "),_("li",[v._v("[ ] 如何设定线程池的大小？")]),v._v(" "),_("li",[v._v("[ ] 如何动态修改线程池的参数？")]),v._v(" "),_("li",[v._v("[ ] 如何设计一个能够根据任务的优先级来执行的线程池？")]),v._v(" "),_("li",[v._v("[ ] Executor 框架介绍")]),v._v(" "),_("li",[v._v("[ ] ThreadPoolExecutor 类介绍（重要）")]),v._v(" "),_("li",[v._v("[ ] 线程池常用的阻塞队列总结")]),v._v(" "),_("li",[v._v("[ ] 线程池原理分析（重要）")]),v._v(" "),_("li",[v._v("[ ] Runnable vs Callable")]),v._v(" "),_("li",[v._v("[ ] shutdown()VSshutdownNow()")]),v._v(" "),_("li",[v._v("[ ] execute() vs submit()")]),v._v(" "),_("li",[v._v("[ ] 几种常见的内置线程池")]),v._v(" "),_("li",[v._v("[ ] FixedThreadPool")]),v._v(" "),_("li",[v._v("[ ] SingleThreadExecutor")]),v._v(" "),_("li",[v._v("[ ] CachedThreadPool")]),v._v(" "),_("li",[v._v("[ ] ScheduledThreadPool")])]),v._v(" "),_("h2",{attrs:{id:"future-类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#future-类"}},[v._v("#")]),v._v(" Future 类")]),v._v(" "),_("ul",[_("li",[v._v("[ ] Future 类有什么用？")]),v._v(" "),_("li",[v._v("[ ] Callable 和 Future 有什么关系？")]),v._v(" "),_("li",[v._v("[ ] CompletableFuture 类有什么用？")])]),v._v(" "),_("h2",{attrs:{id:"aqs"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aqs"}},[v._v("#")]),v._v(" AQS")]),v._v(" "),_("ul",[_("li",[v._v("[ ] AQS 是什么？")]),v._v(" "),_("li",[v._v("[ ] AQS 的原理是什么？")]),v._v(" "),_("li",[v._v("[ ] Semaphore 有什么用？")]),v._v(" "),_("li",[v._v("[ ] Semaphore 的原理是什么？")]),v._v(" "),_("li",[v._v("[ ] CountDownLatch 有什么用？")]),v._v(" "),_("li",[v._v("[ ] CountDownLatch 的原理是什么？")]),v._v(" "),_("li",[v._v("[ ] 用过 CountDownLatch 么？什么场景下用的？")]),v._v(" "),_("li",[v._v("[ ] CyclicBarrier 有什么用？")]),v._v(" "),_("li",[v._v("[ ] CyclicBarrier 的原理是什么？")])]),v._v(" "),_("h2",{attrs:{id:"java-常见并发容器总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-常见并发容器总结"}},[v._v("#")]),v._v(" Java 常见并发容器总结")]),v._v(" "),_("ul",[_("li",[v._v("[ ] ConcurrentHashMap")]),v._v(" "),_("li",[v._v("[ ] CopyOnWriteArrayList")]),v._v(" "),_("li",[v._v("[ ] ConcurrentLinkedQueue")]),v._v(" "),_("li",[v._v("[ ] BlockingQueue")]),v._v(" "),_("li",[v._v("[ ] ArrayBlockingQueue")]),v._v(" "),_("li",[v._v("[ ] LinkedBlockingQueue")]),v._v(" "),_("li",[v._v("[ ] PriorityBlockingQueue")]),v._v(" "),_("li",[v._v("[ ] ConcurrentSkipListMap")])]),v._v(" "),_("h2",{attrs:{id:"其他"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[v._v("#")]),v._v(" 其他")]),v._v(" "),_("ul",[_("li",[v._v("[ ] Atomic 原子类总结")]),v._v(" "),_("li",[v._v("[ ] 虚拟线程")])])])}),[],!1,null,null,null);_.default=a.exports}}]);